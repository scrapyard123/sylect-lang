// SPDX-License-Identifier: MIT

// This is an introduction to Sylect syntax.
// In general, the language tries to avoid extra punctuation.

// You can import other classes/interfaces/annotations.
import {
    java/lang/AutoCloseable
    java/lang/Cloneable
    java/lang/Object
    java/lang/String

    java/lang/Deprecated
    java/lang/SuppressWarnings

    java/io/PrintStream

    java/util/ArrayList
}

// Each file contains exactly one class definition, classes are always public.
class sylect/basic/ClassSyntax
    // Base class is added with " <: ClassName".
    <: Object
    // Interfaces are listed after a colon (no commas needed).
    : AutoCloseable Cloneable
[
    // Sylect considers annotations to be a separate DSL.
    SuppressWarnings[
        value {
            "deprecation"
            "unchecked"
        }
    ]
]

// Fields are always protected and defined as follows. They can be annotated as well.
f1:int [Deprecated[since { "17" }]]
getF1():int { return f1 }
setF1(upd:int):void { f1 = upd }

// Constructors are methods named "constructor", they are not generated by default.
// Lack of constructor means that object cannot be instantiated.
constructor():void { }

// Methods are always public and defined as follows.
// If you want to hide some implementation-specific methods, cast object to interface.
testMethod(
    // Parameters can be annotated.
    a:int [Deprecated]
    // Parameters are not separated by comma.
    // Supported primitive types are int, long, float and double.
    b:int
):int [
    // Methods themselves can be annotated. If there are lots of annotations,
    // annotation block can be formatted like a code block.
    Deprecated
] {
    // You can call methods as follows. If you haven't imported a class,
    // you can refer to it with a fully-qualified identifier.
    java/lang/System.out.println("Hello, World!")

    // Variable scope is the whole method. Variable type is inferred from expression.
    // It is impossible to define an uninitialized variable.
    var var1 = 0
    var unused = 0.0

    // You can assign variables and fields on current object/class.
    f1 = 1
    var1 = a - f1

    // Booleans are represented with integers 0 and 1.
    var e = (10 > 5) + (10L < 5L)

    // It's possible to cast types by prepending [type] before value/expression.
    if -4.5F > [float]-8 {
        e = e + 1
    } else {
        e = e - 1
    }

    // You can use boolean operators in expressions, short-circuiting is supported.
    if !(2 > 3) && (4 < 5) || scaryMethod() {
        e = e + 1
    }

    // Language only supports while loop with (optional) "each" block
    // which is always executed at the end of the iteration.
    var sum = 0
    var i = 0 while i < 8 {
        if (i == 2) {
            continue
        }
        sum = sum + i
    } each {
        i = i + 1
    }

    // Objects are created by calling class name as if it was a method.
    var str = String("he").concat("llo")
    e = e + str.length()

    // Return statement supports expressions.
    return var1 + 2 * (var1 - 1) + e + sum

    // If method is expected to return something and execution
    // falls through the end, an exception will be thrown at runtime.
}

// Will always fail with exception
scaryMethod():int { ArrayList().get(-1) return 0 }

// Methods without code block are abstract.
abstractMethod():void

// Calling abstract methods (including methods in interface) that has not been
// implemented leads to java.lang.AbstractMethodError exception.
// close():void { }

// Fields and methods can be static.
static f2:long
static staticTestMethod():PrintStream {
    return java/lang/System.err
}

// Types like bool, byte, char, short and all arrays have only black-box
// support which means that you can pass them, but can't directly operate on.
static main(args:String[]!):void { }

// Continue with InterfaceSyntax.sy
